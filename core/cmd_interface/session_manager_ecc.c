// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "crypto/aes.h"
#include "crypto/ecc.h"
#include "crypto/hash.h"
#include "riot/riot_key_manager.h"
#include "session_manager.h"
#include "session_manager_ecc.h"


/**
 * Use provided device public key and nonce along with Cerberus RIoT leaf key to generate shared
 * AES key for session encryption. 
 *
 * @param session Session manager instance to utilize.
 * @param pub_key Device ECC public key. 
 * @param pub_key_len Device ECC public key length. 
 * @param device_nonce 32 byte random nonce generated by device used for AES key generation.
 * @param cerberus_nonce 32 byte random nonce generated by Cerberus used for AES key generation.
 * @param aes_key Buffer to store generated AES key.
 * @param aes_key_len AES key buffer length.
 *
 * @return Completion status, 0 if success or an error code.
 */
static int session_manager_ecc_generate_aes_key (struct session_manager_ecc *session, 
	const uint8_t *pub_key, size_t pub_key_len, const uint8_t *device_nonce, 
	const uint8_t *cerberus_nonce, uint8_t *aes_key, size_t aes_key_len)
{
	const struct riot_keys *keys;
	uint8_t *shared_secret;
	struct ecc_private_key private_key;
	struct ecc_public_key public_key;
	struct hmac_engine hmac;
	int status;

	keys = riot_key_manager_get_riot_keys (session->base.riot);
	if (keys == NULL) {
		return SESSION_MANAGER_INVALID_ARGUMENT;
	}

	status = session->ecc->init_key_pair (session->ecc, keys->alias_key, keys->alias_key_length,
		&private_key, NULL);
	riot_key_manager_release_riot_keys (session->base.riot, keys);
	if (status != 0) {
		return status;
	}

	status = session->ecc->init_public_key (session->ecc, pub_key, pub_key_len, &public_key);
	if (status != 0) {
		session->ecc->release_key_pair (session->ecc, &private_key, NULL);
		return status;
	}

	status = session->ecc->get_shared_secret_max_length (session->ecc, &private_key);
	if (ROT_IS_ERROR (status)) {
		goto free_ecc_keys;
	}

	shared_secret = platform_malloc (status);
	if (shared_secret == NULL) {
		status = SESSION_MANAGER_NO_MEMORY;
		goto free_ecc_keys;
	}

	status = session->ecc->compute_shared_secret (session->ecc, &private_key, &public_key, 
		shared_secret, status);
	if (ROT_IS_ERROR (status)) {
		goto free_shared_secret;
	}

	status = hash_hmac_init (&hmac, session->base.hash, HMAC_SHA256, shared_secret, status);
	if (status != 0) {
		goto free_shared_secret;
	}

	status = hash_hmac_update (&hmac, device_nonce, SESSION_MANAGER_NONCE_LEN);
	if (status != 0) {
		hash_hmac_cancel (&hmac);
		goto free_shared_secret;
	}

	status = hash_hmac_update (&hmac, cerberus_nonce, SESSION_MANAGER_NONCE_LEN);
	if (status != 0) {
		hash_hmac_cancel (&hmac);
		goto free_shared_secret;
	}

	status = hash_hmac_finish (&hmac, aes_key, aes_key_len);

free_shared_secret:
	platform_free (shared_secret);

free_ecc_keys:
	session->ecc->release_key_pair (session->ecc, &private_key, &public_key);

	return status;
}

static int session_manager_ecc_establish_session (struct session_manager *session, uint8_t eid, 
	const uint8_t *pub_key, uint32_t pub_key_len, bool pair_key)
{
	struct session_manager_ecc *session_mgr = (struct session_manager_ecc*) session;
	struct session_manager_ecc_entry *curr_session;
	int status;

	if ((session_mgr == NULL) || (pub_key == NULL)) {
		return SESSION_MANAGER_INVALID_ARGUMENT;
	}
	
	curr_session = (struct session_manager_ecc_entry*) session_manager_get_session (
		&session_mgr->base, eid);
	if (curr_session != NULL) {
		if (curr_session->entry.session_state != SESSION_STATE_SETUP) {
			return SESSION_MANAGER_INVALID_ORDER;
		}

		if ((curr_session->pub_key_len != pub_key_len) || 
			(memcmp (pub_key, curr_session->pub_key, pub_key_len) != 0)) {
			if (curr_session->entry.paired_key) {
				return SESSION_MANAGER_UNEXPECTED_PUBKEY;
			}
			else {
				curr_session->pub_key_len = pub_key_len;
				memcpy (curr_session->pub_key, pub_key, pub_key_len);
				curr_session->entry.paired_key = pair_key;
			}
		}
	}
	else {
		return SESSION_MANAGER_UNEXPECTED_EID;
	}

	status = session_manager_ecc_generate_aes_key (session_mgr, pub_key, pub_key_len, 
		curr_session->entry.device_nonce, curr_session->entry.cerberus_nonce, 
		curr_session->entry.aes_key, sizeof (curr_session->entry.aes_key));
	if (status != 0) {
		return status;
	}

	curr_session->entry.session_state = SESSION_STATE_ESTABLISHED;

	return status;
}

/**
 * Initialize session manager instance and use the provided session manager entries table
 *
 * @param session Session manager instance to initialize.
 * @param aes AES engine to utilize for packet encryption/decryption. 
 * @param ecc ECC engine to utilize for AES key generation. 
 * @param hash Hash engine to utilize for AES key generation.
 * @param rng RNG engine used to generate IV buffers. 
 * @param riot RIoT key manager to utilize to get alias key for AES key generation.   
 * @param sessions_table Table to use to store session manager entries. 
 * @param num_sessions Number of sessions to support.
 * @param sessions_table_preallocated Flag indicating whether sessions table was statically 
 * 	allocated.
 *
 * @return Initialization status, 0 if success or an error code.
 */
static int session_manager_ecc_init_internal (struct session_manager_ecc *session, 
	struct aes_engine *aes, struct ecc_engine *ecc, struct hash_engine *hash, 
	struct rng_engine *rng, struct riot_key_manager *riot, uint8_t *sessions_table, 
	size_t num_sessions, bool sessions_table_preallocated)
{
	int status; 

	if (ecc == NULL) {
		return SESSION_MANAGER_INVALID_ARGUMENT;
	}

	status = session_manager_init (&session->base, aes, hash, rng, riot, sessions_table, 
		num_sessions, sizeof (struct session_manager_ecc_entry), sessions_table_preallocated);
	if (status == 0) {
		session->base.add_session = session_manager_add_session;
		session->base.establish_session = session_manager_ecc_establish_session;
		session->base.is_session_established = session_manager_is_session_established;
		session->base.decrypt_message = session_manager_decrypt_message;
		session->base.encrypt_message = session_manager_encrypt_message;
		session->base.reset_session = session_manager_reset_session;
		session->ecc = ecc;
	}

	return status;
}

/**
 * Initialize session manager instance and use the provided session manager entries table
 *
 * @param session Session manager instance to initialize.
 * @param aes AES engine to utilize for packet encryption/decryption. 
 * @param ecc ECC engine to utilize for AES key generation. 
 * @param hash Hash engine to utilize for AES key generation.
 * @param rng RNG engine used to generate IV buffers. 
 * @param riot RIoT key manager to utilize to get alias key for AES key generation.   
 * @param sessions_table Table to use to store session manager entries. 
 * @param num_sessions Number of sessions to support.
 *
 * @return Initialization status, 0 if success or an error code.
 */
int session_manager_ecc_init_table_preallocated (struct session_manager_ecc *session, 
	struct aes_engine *aes, struct ecc_engine *ecc, struct hash_engine *hash, 
	struct rng_engine *rng, struct riot_key_manager *riot, 
	struct session_manager_ecc_entry *sessions_table, size_t num_sessions)
{
	return session_manager_ecc_init_internal (session, aes, ecc, hash, rng, riot, 
		(uint8_t*) sessions_table, num_sessions, true);
}

/**
 * Initialize session manager instance
 *
 * @param session Session manager instance to initialize.
 * @param aes AES engine to utilize for packet encryption/decryption. 
 * @param ecc ECC engine to utilize for AES key generation. 
 * @param hash Hash engine to utilize for AES key generation. 
 * @param rng RNG engine used to generate IV buffers. 
 * @param riot RIoT key manager to utilize to get alias key for AES key generation. 
 * @param num_sessions Number of sessions to support.
 *
 * @return Initialization status, 0 if success or an error code.
 */
int session_manager_ecc_init (struct session_manager_ecc *session, 
	struct aes_engine *aes, struct ecc_engine *ecc, struct hash_engine *hash, 
	struct rng_engine *rng, struct riot_key_manager *riot, size_t num_sessions)
{
	int status;
	uint8_t *sessions_table;
	
	if (ecc == NULL) {
		return SESSION_MANAGER_INVALID_ARGUMENT;
	}

	sessions_table = platform_malloc (sizeof (struct session_manager_ecc_entry) * num_sessions);
	if (sessions_table == NULL) {
		return SESSION_MANAGER_NO_MEMORY;
	}

	status = session_manager_ecc_init_internal (session, aes, ecc, hash, rng, riot, sessions_table, 
		num_sessions, true);
	if (status != 0) {
		platform_free (sessions_table);
	}

	return status;
}

/**
 * Release session manager
 *
 * @param session Session manager instance to release
 */
void session_manager_ecc_release (struct session_manager_ecc *session)
{
	session_manager_release (&session->base);
}
