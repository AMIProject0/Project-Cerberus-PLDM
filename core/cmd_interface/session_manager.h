// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#ifndef SESSION_MANAGER_H_
#define SESSION_MANAGER_H_


#include <stdint.h>
#include <stdbool.h>
#include "crypto/aes.h"
#include "crypto/hash.h"
#include "crypto/rng.h"
#include "riot/riot_key_manager.h"
#include "status/rot_status.h"
#include "cmd_interface.h"
#include "cerberus_protocol.h"


#define SESSION_MANAGER_NONCE_LEN						32
#define SESSION_MANAGER_TRAILER_LEN						(CERBERUS_PROTOCOL_AES_GCM_TAG_LEN + CERBERUS_PROTOCOL_AES_IV_LEN)


enum {
	SESSION_STATE_UNUSED = 0,							/**< Session slot not used currently */
	SESSION_STATE_SETUP,								/**< Session currently being established */
	SESSION_STATE_ESTABLISHED,							/**< Session successfully established */
};

/**
 * Entry in table holding session information and cached keys.  
 */
struct session_manager_entry {
	uint8_t aes_key[AES256_KEY_LENGTH];					/**< Cache of AES session key */
	uint8_t device_nonce[SESSION_MANAGER_NONCE_LEN];	/**< Nonce generated by device to use during session establishment */	
	uint8_t cerberus_nonce[SESSION_MANAGER_NONCE_LEN];	/**< Nonce generated by Cerberus to use during session establishment */
	uint8_t eid;										/**< EID of other device participating in session */
	uint8_t session_state;								/**< Current session state */
	bool paired_key;									/**< Boolean indicating whether public key is paired to EID */
};

/**
 * Module which holds engines needed for session manager operation and caches session keys. Each 
 * instance is intended to be dedicated to a single command interface. 
 */
struct session_manager {
	/**
	 * Use provided nonces to either create or restart session with device specified using EID. 
	 *
	 * @param session Session manager instance to utilize.
	 * @param eid Device EID.
	 * @param device_nonce 32 byte random nonce generated by device used for AES key generation.
	 * @param cerberus_nonce 32 byte random nonce generated by Cerberus used for AES key generation.
	 *
	 * @return Completion status, 0 if success or an error code.
	 */
	int (*add_session) (struct session_manager *session, uint8_t eid, const uint8_t *device_nonce, 
		const uint8_t *cerberus_nonce);

	/**
	 * Establish session for a device and generate AES session key using Cerberus and device alias 
	 * keys. 
	 *
	 * @param session Session manager instance to utilize.
	 * @param eid Device EID. 
	 * @param pub_key Device public key. 
	 * @param pub_key_len Device public key length.
	 * @param pair_key Pair public key to device. 
	 *
	 * @return Completion status, 0 if success or an error code.
	 */
	int (*establish_session) (struct session_manager *session, uint8_t eid, const uint8_t *pub_key, 
		uint32_t pub_key_len, bool pair_key);

	/**
	 * Check if device EID is on an established session. 
	 *
	 * @param session Session manager instance to utilize.
	 * @param eid Device EID.  
	 *
	 * @return 1 if established, 0 if not or an error code.
	 */
	int (*is_session_established) (struct session_manager *session, uint8_t eid);

	/**
	 * Decrypt message using AES session key generated for session with device with requested EID.
	 *
	 * @param session Session manager instance to utilize.
	 * @param request Request to decrypt. 
	 *
	 * @return Completion status, 0 if success or an error code.
	 */
	int (*decrypt_message) (struct session_manager *session, struct cmd_interface_request *request);

	/**
	 * Encrypt message using AES session key generated for session with device with requested EID.
	 * Output will contain encrypted message followed by the AES GCM tag and AES initialization 
	 * vector generated and used.
	 *
	 * @param session Session manager instance to utilize.
	 * @param request Request to encrypt. 
	 *
	 * @return Completion status, 0 if success or an error code.
	 */
	int (*encrypt_message) (struct session_manager *session, struct cmd_interface_request *request);

	struct aes_engine *aes;					/**< AES engine used to encrypt/decrypt session data */
	struct hash_engine *hash;				/**< Hashing engine used to generate AES shared key */
	struct rng_engine *rng;					/**< RNG engine used to generate IV buffers */
	struct riot_key_manager *riot;			/**< RIoT key manager containing alias key */
	size_t entry_len;						/**< Sessions table entry length */
	size_t num_sessions;					/**< Total number of supported sessions */
	uint8_t *sessions_table;				/**< Table of supported device sessions */
	bool sessions_table_preallocated;		/**< Flag indicating if sessions table was provided by caller */
};

/* Internal functions for use by derived types. */
int session_manager_init (struct session_manager *session, struct aes_engine *aes, 
	struct hash_engine *hash, struct rng_engine *rng, struct riot_key_manager *riot, 
	uint8_t *sessions_table, size_t num_sessions, size_t entry_len, 
	bool sessions_table_preallocated);
void session_manager_release (struct session_manager *session);

int session_manager_add_session (struct session_manager *session, uint8_t eid, 
	const uint8_t *device_nonce, const uint8_t *cerberus_nonce);
int session_manager_decrypt_message (struct session_manager *session, 
	struct cmd_interface_request *request);
int session_manager_encrypt_message (struct session_manager *session, 
	struct cmd_interface_request *request);
int session_manager_is_session_established (struct session_manager *session, uint8_t eid);

struct session_manager_entry* session_manager_get_session (struct session_manager *session, 
	uint8_t eid);

#define	SESSION_MANAGER_ERROR(code)				ROT_ERROR (ROT_MODULE_SESSION_MANAGER, code)

/**
 * Error codes that can be generated by the session manager.
 */
enum {
	SESSION_MANAGER_INVALID_ARGUMENT = SESSION_MANAGER_ERROR (0x00),  			/**< Input parameter is null or not valid. */
	SESSION_MANAGER_NO_MEMORY = SESSION_MANAGER_ERROR (0x01),		  			/**< Memory allocation failed. */
	SESSION_MANAGER_UNEXPECTED_EID = SESSION_MANAGER_ERROR (0x02),  			/**< Device EID unexpected. */
	SESSION_MANAGER_UNEXPECTED_PUBKEY = SESSION_MANAGER_ERROR (0x03),  			/**< Device public key unexpected. */
	SESSION_MANAGER_SESSION_NOT_ESTABLISHED = SESSION_MANAGER_ERROR (0x04), 	/**< Encryption/Decryption attempted without establishing session. */
	SESSION_MANAGER_INVALID_ORDER = SESSION_MANAGER_ERROR (0x05), 				/**< Invalid order attempted for session establishment. */
	SESSION_MANAGER_FULL = SESSION_MANAGER_ERROR (0x06),						/**< Session manager at capacity and cannot support more sessions. */
	SESSION_MANAGER_MALFORMED_MSG = SESSION_MANAGER_ERROR (0x07),				/**< Provided message to decrypt invalid. */
	SESSION_MANAGER_BUF_TOO_SMALL = SESSION_MANAGER_ERROR (0x08),				/**< Provided output buffer too small for operation. */
};

#endif // SESSION_MANAGER_H_
