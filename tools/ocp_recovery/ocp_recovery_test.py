#!/usr/bin/env python3

"""
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT license.
"""

import sys
import re
import argparse
import subprocess
import secrets
import tempfile


def log_output (text, log_file = None):
    """
    Log test output.

    :param text:  Text data to log.
    :param log_file:  File output for the log.  If there is no file, the text will be printed to
        the screen.
    """

    if (log_file):
        with open (log_file, "a") as out:
            out.write (text)
    else:
        print (text, end = "")

def check_result (result, log_file = None):
    """
    Check the result for a single application execution.  If the execution failed, this will
    terminate the test script.

    :param result:  Completion result object from the application execution.
    :param log_file:  File output for the results.  If there is no file, results will be printed to
        the screen.
    """

    log_output (result.stdout, log_file)

    if (result.returncode != 0):
        log_output ("\nFAILURE!!!!!\n", log_file)
        sys.exit (1)

def get_ocp_options (args):
    """
    Construct the list of options for OCP application execution.

    :param args:  The user-defined arguments.

    :return A list containing the application parameters.  No command for the application will be
        added to the list.
    """
    ocp_args = [args.path, "-d", args.dev]

    if (args.addr):
        ocp_args.extend (["-a", args.addr])

    if (args.cms_read):
        ocp_args.extend (["-R", str (args.cms_read)])

    if (args.cms_write):
        ocp_args.extend (["-W", str (args.cms_write)])

    if (args.no_pec):
        ocp_args.append ("-p")

    for i in range (args.verbose):
        ocp_args.append ("-v")

    return ocp_args

def run_cmd (args, cmd, timeout = 10):
    """
    Run a single OCP application command.

    :param args:  The user-defined arguments.
    :param cmd:  The list of command-specific application arguments.
    :param timeout:  Timeout to apply to command execution.

    :return Output generated by the command.
    """

    ocp_args = get_ocp_options (args)
    ocp_args.extend (cmd)

    log_output ("Cmd: {0}\n\n".format (" ".join (ocp_args)), args.log)

    result = subprocess.run (ocp_args, capture_output = True, timeout = timeout, text = True)
    check_result (result, log_file = args.log)

    return result.stdout

def run_cmd_sequence (args, cmd_list, timeout = 10):
    """
    Run a sequence of OCP application commands.

    :param args:  The user-defined arguments.
    :param cmd_list:  A list of commands to execute.  Each entry will be a list of command-specific
        application arguments.
    :param timeout:  Timeout to apply to each command being executed.  All commands use the same
        timeout value.
    """

    for cmd in cmd_list:
        run_cmd (args, cmd, timeout = timeout)

def check_ocp_status (args, expected = 0):
    """
    Check for protocol errors reported by the OCP target.  If the protocol status is not the
    expected value, the test script will exit.

    :param args:  The user-defined arguments.
    :param expected:  The expected protocol error states.
    """

    ocp_status = run_cmd (args, ["device_status"])

    proto_status = re.search ("Protocol Error: (0x..)", ocp_status)
    if (not proto_status):
        log_output ("Could not determine protocol status.\n", args.log)
        sys.exit (1)

    if (expected != int (proto_status.group (1), 16)):
        log_output ("Unexpected protocol status.  Expected {0}.\n".format (hex (expected)),
            args.log)
        sys.exit (1)

def get_cms_size (args, cms):
    """
    Determine the size of the specified CMS

    :param args:  The user-defined arguments.
    :param cms:  The CMS to check.

    :return The number of bytes in the CMS
    """

    run_cmd (args, ["-w", "indirect_ctrl", hex (cms), "0x00", "0x00"])
    indirect_status = run_cmd (args, ["indirect_status"])
    check_ocp_status (args)

    bytes = re.search ("Region Size:.* -> (0x.*) bytes", indirect_status)
    if (not bytes):
        log_output ("Could not determine region size.\n", args.log)
        sys.exit (1)

    return int (bytes.group (1), 16)

def run_stress_cmd (args):
    """
    Run the 'show_all' command to stress reading each supported command.

    :param args:  The user-defined arguments.
    """

    run_cmd (args, ["show_all"])

def run_stress_cms (args):
    """
    Write random data to an entire CMS.  Verify that the data was written correctly.

    :param args:  The user-defined arguments.
    """

    with tempfile.NamedTemporaryFile (delete = True) as cms_file:
        cms_data = secrets.token_bytes (get_cms_size (args, args.stress_cms))
        cms_file.write (cms_data)

        run_cmd_sequence (args, [["-c", str (args.stress_cms), "load_img", cms_file.name],
            ["-c", str (args.stress_cms), "verify_img", cms_file.name]], timeout = 300)

def run_verify_cms (args, cms, expected):
    """
    Verify the contents of a CMS against a file.

    :param args:  The user-defined arguments.
    :param cms:  The CMS to verify.
    :param expected:  The expected data contained in the CMS.
    """

    run_cmd (args, ["-c", cms, "verify_img", expected], timeout = 300)

def run_read_log (args, cms, is_cerberus = True):
    """
    Read and parse log data stored in a CMS.

    :param args:  The user-defined arguments.
    :param cms:  The CMS that contains the log.
    :param is_cerberus:  Indicate if the log data is stored in Cerberus format.
    """

    log_args = []
    if (is_cerberus):
        log_args.append ("-l")

    log_args.extend (["-c", cms, "read_log"])

    run_cmd (args, log_args)


if __name__ == '__main__':
    parser = argparse.ArgumentParser (description = "Tester for OCP recovery interface")

    parser.add_argument ("--path", action = "store", default = "./ocp_recovery",
        help = "Path to the testing application (default: ./ocp_recovery)")
    parser.add_argument ("--dev", action = "store", default = "1",
        help = "I2C device number connected to the OCP recovery interface (default: 1)")
    parser.add_argument ("--addr", action = "store",
        help = "I2C address of the OCP device (default: 0x69)")
    parser.add_argument ("--no_pec", action = "store_true",
        help = "Do not use PEC bytes for any commands")
    parser.add_argument ("--cms_read", action = "store", type = int,
        help = "Set the maximum block size for reading from a CMS")
    parser.add_argument ("--cms_write", action = "store", type = int,
        help = "Set the maximum block size for writing to a CMS")
    parser.add_argument ("--verbose", action = "store", type = int, default = 0,
        help = "Set verbosity of test application output")

    parser.add_argument ("--log", action = "store",
        help = "Path to a log file that should be written with the test output")
    parser.add_argument ("--count", action = "store", type = int, default = 1,
        help = "Specify the number of stress test loops to execute.  0 for no limit. (default: 1)")
    parser.add_argument ("--stress_cmd", action = "store_true",
        help = "Stress different command handling by running 'show_all'")
    parser.add_argument ("--stress_cms", action = "store", type = int,
        help = "Stress read and write operations by fully writing and verifying a CMS")
    parser.add_argument ("--verify_cms", action = "append", default = [],
        help = "Verify the contents of a CMS against a provided file.  Specify <cms>,<file>")
    parser.add_argument ("--read_log", action = "append", default = [],
        help = "Read and parse log data from a CMS.  For an OCP log, specify <cms>,ocp")

    args = parser.parse_args ()

    # Create an empty log file
    if (args.log):
        open (args.log, "w").close ()

    for read_log in args.read_log:
        cms = read_log.split (",")

        log_output ("-------------------------------------\n", args.log)
        log_output ("--  READ LOG: CMS {0}\n".format (cms[0]), args.log)
        log_output ("-------------------------------------\n", args.log)
        log_output ("\n", args.log)

        run_read_log (args, cms[0], ((len (cms) == 1) or (cms[1] != "ocp")))
        log_output ("\n", args.log)

    for verify_cms in args.verify_cms:
        cms = verify_cms.split (",")

        log_output ("-------------------------------------\n", args.log)
        log_output ("--  VERIFY CMS {0}\n".format (cms[0]), args.log)
        log_output ("-------------------------------------\n", args.log)
        log_output ("\n", args.log)

        run_verify_cms (args, cms[0], cms[1])

    i = 0
    while ((not args.count) or (i < args.count)):
        i += 1
        log_output ("-------------------------------------\n", args.log)
        log_output ("-- STRESS ITERATION: {0}\n".format (i), args.log)
        log_output ("-------------------------------------\n", args.log)
        log_output ("\n", args.log)

        if (args.stress_cmd):
            run_stress_cmd (args)

        if (args.stress_cms is not None):
            run_stress_cms (args)
